//////////////////////////////////////////////////////////////////////
// C++ source file generated by SpecC V2.2.1
// Design: main
// File:   main.cc
// Time:   Fri Dec 15 18:05:22 2017
//////////////////////////////////////////////////////////////////////

// Note: User-defined include files are inlined in this file.

// Note: System-defined include files are inlined in this file.

#include "main.h"


unsigned int _IDcnt = 0;
// variable definitions //////////////////////////////////////////////

#line 11 "PE_replay.sc"
unsigned int arr_spikes[1024] = { 0u };
unsigned int ref_period[1024] = { 0u };

unsigned int post_addresses[1048576] = { 4294967295u };
unsigned int time_arr[1024] = { 0u };

unsigned int spikes[1000000];
unsigned int t_spikes[1000000];

#line 13 "snn.sh"
const unsigned int PE_ADDR[37] = { 
  4244832256u,
  4261609472u,
  4278386688u,
  196608u,

  4244766720u,
  4261543936u,
  4278321152u,
  131072u,
  16908288u,

  4244701184u,
  4261478400u,
  4278255616u,
  65536u,
  16842752u,
  33619968u,

  4244635648u,
  4261412864u,
  4278190080u,
  0u,
  16777216u,
  33554432u,
  50331648u,

  4278124544u,
  4294901760u,
  16711680u,
  33488896u,
  50266112u,
  67043328u,

  4294836224u,
  16646144u,
  33423360u,
  50200576u,
  66977792u,

  16580608u,
  33357824u,
  50135040u,
  66912256u };

// behavior class definitions ////////////////////////////////////////

#line 77 "main.cc"
PE_node::PE_node(unsigned int _idcnt, unsigned int (&id))
    : _specc::behavior(_idcnt), id(id),
    max_spikes(0u),
    spikes_i(0u),
    time(0u)
{   
}

PE_node::~PE_node(void)
{   
}

#line 200 "PE_replay.sc"
void PE_node::compute_currents()
{   




    int i;
    for(i = 0; i < 1024; i++ )
    {   
	unsigned int t_arr; unsigned int t_diff;
	t_arr = time_arr[i];
	t_diff = time - t_arr;

	if (t_arr != 0 && t_diff >= 0 && t_diff <= 500) {
	    _specc::waitfor((500));
	}
	else 

	    if (t_arr != 0 && t_diff > 500)
		arr_spikes[i] = 0;
    }
}



void PE_node::compute_voltages()
{   
    int i;
    unsigned int n;
    printf("At time %f", time * 1.000000000000000e-01);


    for(i = 0; i < 1024; i++ )
    {   

	if (ref_period[i] != 0)
	{   
	    ref_period[i]-- ;
	}
	else 

	{   


	    _specc::waitfor((500));
	    if (t_spikes[spikes_i] == time)
	    {   
		n = spikes[spikes_i];
		if (ref_period[n] != 0) ref_period[n]-- ;
		else  {

		    ref_period[n] = 200;
		    send_spikes(n);
		    spikes_i++ ;
		    printf(" %d Spiked ", n);
		}
	    }
	}
    }


    printf("\n");
}

#line 142 "PE_replay.sc"
void PE_node::initialize()
{   
    int i; int j;
    my_PE_addr = id;

    for(i = 0; i < 1024; i++ )
	for(j = 0; j < 1024; j++ )
	    post_addresses[1024 * i + j] = 2863267840u;

    read_mapping();
}

#line 263 "PE_replay.sc"
void PE_node::main()
{   

    initialize();


    while(time < 500)
    {   

	compute_currents();
	compute_voltages();

	time = time + 1;
    }

    print_spikes();
}

#line 34 "PE_replay.sc"
void PE_node::print_spikes()
{   
    int i;
    for(i = 0; i < 1024; i++ )
    {   
	printf("Spikes for neuron %d: %d\n", i, spikes[i]);
    }
}

void PE_node::print_times()
{   
    int i;
    for(i = 0; i < 1024; i++ )
    {   
	printf("Spike for neuron %d at %fms\n", i, time * 1.000000000000000e-01);
    }
}

void PE_node::read_mapping()
{   
    struct _IO_FILE *input_file;
    char val_string[8000];
    char ch;
    int first = 0; int valid = 0;
    float value_f;
    unsigned int value_i;
    int i = 0; int neuron = 1; int synapse = 0;
    input_file = fopen("connectivity_matrix_mod", "r");

    while(( -1) != (ch = fgetc(input_file)))
    {   
	if (ch == '\n')
	{   
	    i = 0;
	    synapse = 0;
	    first = 0;
	    valid = 0;
	}
	else  if (ch == ' ')
	    {   
		unsigned int adr = 0u;
		val_string[i] = '\000';
		value_i = atol(val_string);
		adr = value_i & 4294901760u;

		if (first != 0 && valid == 1)
		{   
		    post_addresses[1024 * neuron + synapse] = value_i;
		    synapse++ ;
		}
		else 
		{   
		    if (adr == PE_ADDR[my_PE_addr])
		    {   
			neuron = value_i & 65535;
			first++ ;
			valid = 1;
		    }
		}

		i = 0;
	    }
	    else 
	    {   
		val_string[i] = ch;
		i++ ;
	    }
    }

    fclose(input_file);

    neuron = 0;
    input_file = fopen("spike_matrix_mod", "r");
    i = 0;
    while(( -1) != (ch = fgetc(input_file)))
    {   
	if (ch == '\n')
	{   
	    unsigned int adr = 0u;
	    val_string[i] = '\000';
	    value_i = atol(val_string);
	    adr = value_i & 4294901760u;
	    if (adr == PE_ADDR[my_PE_addr])
	    {   
		spikes[max_spikes] = value_i & 65535;
		max_spikes++ ;
	    }
	    i = 0;
	}
	else 
	    if (ch == ' ')
	    {   
		val_string[i] = '\000';
		value_f = atof(val_string);
		t_spikes[max_spikes] = value_f * 10;
		i = 0;
	    }
	    else 
	    {   
		val_string[i] = ch;
		i++ ;
	    }
    }
    fclose(input_file);
}

#line 154 "PE_replay.sc"
void PE_node::register_spikes(unsigned int input_neuron_addr, unsigned int dest_neuron_addr, unsigned int t_local)
{   


    unsigned int t_delay = 0u;


    int i;
    i = dest_neuron_addr & 65535;

    if (time > (t_local + t_delay)) printf("Sync error\n");



    arr_spikes[i]++ ;
    time_arr[i] = ((time_arr[i] * (arr_spikes[i] - 1)) + t_local) / arr_spikes[i];


    _specc::waitfor((500));
}

#line 182 "PE_replay.sc"
void PE_node::send_spikes(unsigned int neuron_num)
{   
    int j;
    unsigned int neuron_addr; unsigned int post_PE_addr; unsigned int post_addr;
    neuron_addr = PE_ADDR[my_PE_addr] + neuron_num;
    for(j = 0; j < 1024; j++ )
    {   
	post_addr = post_addresses[1024 * neuron_num + j];
	if (post_addr != 2863267840u)
	{   
	    post_PE_addr = post_addr & 4294901760u;
	    if (post_PE_addr == PE_ADDR[my_PE_addr]) send_spikes_internal(neuron_addr, post_addr, time);
	    else  send_spikes_external(neuron_addr, post_addr, time);
	}
    }
}

#line 175 "PE_replay.sc"
void PE_node::send_spikes_external(unsigned int neuron_addr, unsigned int post_addr, unsigned int t_local) {
}
void PE_node::send_spikes_internal(unsigned int neuron_addr, unsigned int post_addr, unsigned int t_local)
{   
    register_spikes(neuron_addr, post_addr, t_local);
}

#line 342 "main.cc"
Main::Main(unsigned int _idcnt)
    : _specc::class_type(_idcnt),
    i(0u),
    PE_0(_IDcnt, i)
{   
}

Main::~Main(void)
{   
}

#line 12 "main.sc"
int Main::main()
{   
    PE_0.main();
    return 0;
}

#line 361 "main.cc"
Main _scc_main(_IDcnt);

int main()
{   
    int _scc_main_return;
    
    _specc::start();
    _scc_main_return = _scc_main.main();
    _specc::end();
    return(_scc_main_return);
}

// function definitions //////////////////////////////////////////////

#line 13 "neuron_model.sh"
float LIF_slope(float V, float I)
{   
    float ret_val; float t1; float t2;
    t1 = V -  -70;
    t2 = I - 30 * t1;
    ret_val = t2 / 300;
    return ret_val;
}

#line 9 "synapse_model.sh"
float synaptic_current(unsigned int w, float t_diff)
{   
    float I;
    I = 1 * w * (exp(( -t_diff) / 15) - exp((( -t_diff) * 4.000000000000000e+00) / 15));
    return I;
}

#line 394 "main.cc"
void _scc_bit4_err_handle(
    const _bit4& bit4vec)
{   
    char temp_bits[1024], *p;
    p=bit2str(2,&temp_bits[1023], bit4vec);
    _specc::abort(
	"ERROR:\t Casting a bit4 vector failed \n"
	"Bit4 vector contains X/Z values %s\n"
	"Simulation aborted.\n", p);
	
}

//////////////////////////////////////////////////////////////////////
// End of file main.cc
//////////////////////////////////////////////////////////////////////
