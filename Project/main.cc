//////////////////////////////////////////////////////////////////////
// C++ source file generated by SpecC V2.2.1
// Design: main
// File:   main.cc
// Time:   Fri Dec 15 21:17:06 2017
//////////////////////////////////////////////////////////////////////

// Note: User-defined include files are inlined in this file.

// Note: System-defined include files are inlined in this file.

#include "main.h"


unsigned int _IDcnt = 0;
// variable definitions //////////////////////////////////////////////

#line 12 "PE_replay.sc"
unsigned int arr_spikes[1024] = { 0u };
unsigned int ref_period[1024] = { 0u };

unsigned int post_addresses[1048576] = { 4294967295u };
unsigned int time_arr[1024] = { 0u };

unsigned int spikes[1000000];
unsigned int t_spikes[1000000];

unsigned int comm[37] = { 0u };

#line 13 "snn.sh"
const unsigned int PE_ADDR[37] = { 
  4244832256u,
  4261609472u,
  4278386688u,
  196608u,

  4244766720u,
  4261543936u,
  4278321152u,
  131072u,
  16908288u,

  4244701184u,
  4261478400u,
  4278255616u,
  65536u,
  16842752u,
  33619968u,

  4244635648u,
  4261412864u,
  4278190080u,
  0u,
  16777216u,
  33554432u,
  50331648u,

  4278124544u,
  4294901760u,
  16711680u,
  33488896u,
  50266112u,
  67043328u,

  4294836224u,
  16646144u,
  33423360u,
  50200576u,
  66977792u,

  16580608u,
  33357824u,
  50135040u,
  66912256u };

// channel class definitions /////////////////////////////////////////

#line 79 "main.cc"
c_packet_queue::c_packet_queue(const unsigned long int (&size))
    : _specc::channel(), size(size),
    buffer(0),
    n(0ul),
    p(0ul),
    wr(0ul),
    ws(0ul)
{   
}

c_packet_queue::~c_packet_queue(void)
{   
}

#line 13 "c_packet_queue.sc"
void c_packet_queue::cleanup(void) { if ( !n) { free(buffer); buffer = 0;
    }
}

#line 13 "c_packet_queue.sc"
void c_packet_queue::receive(packet *d) { while( !n) { wr++ ; _specc::wait(event(&r), ((void*)0)); wr-- ;
    }

#line 13 "c_packet_queue.sc"
    if (n <= p) {  *d = buffer[p - n];
    }
    else 

#line 13 "c_packet_queue.sc"
    {     *d = buffer[p + size - n];
    }

#line 13 "c_packet_queue.sc"
    n-- ; if (ws) { _specc::notify(event(&s), ((void*)0));
    }

#line 13 "c_packet_queue.sc"
    cleanup();
}

#line 13 "c_packet_queue.sc"
void c_packet_queue::send(packet d) { while(n >= size) { ws++ ; _specc::wait(event(&s), ((void*)0)); ws-- ;
    }

#line 13 "c_packet_queue.sc"
    setup(); buffer[p] = d; p++ ; if (p >= size) { p = 0;
    }

#line 13 "c_packet_queue.sc"
    n++ ; if (wr) { _specc::notify(event(&r), ((void*)0));
    }
}

#line 13 "c_packet_queue.sc"
void c_packet_queue::setup(void) { if ( !buffer) { packet dummy; unsigned long int i; if ( !(buffer = (packet *)malloc(sizeof(packet) * size))) { perror("c_typed_queue"); abort();
	}

#line 13 "c_packet_queue.sc"
	for(i = 0; i < size; i++ ) { memcpy( &buffer[i],  &dummy, sizeof(packet));
	}
    }
}

// behavior class definitions ////////////////////////////////////////

#line 145 "main.cc"
PE_node::PE_node(unsigned int _idcnt, unsigned int (&id))
    : _specc::behavior(_idcnt), id(id),
    max_spikes(0u),
    spikes_i(0u),
    time(0u)
{   
}

PE_node::~PE_node(void)
{   
}

#line 142 "PE_replay.sc"
void PE_node::accumulate_stats()
{   
    struct _IO_FILE *out_file;
    char fname[10] = "PE";
    char result[10];
    int i;
    sprintf(result, "%u", my_PE_addr);
    if (my_PE_addr < 10) {
	fname[3] = result[0];
	fname[4] = '\000';
    }
    else  {
	fname[3] = result[0];
	fname[4] = result[1];
	fname[5] = '\000';
    }
    out_file = fopen(fname, "w");

    for(i = 0; i < 37; i++ )
    {   
	fprintf(out_file, "%u\n", comm[i]);
    }
    fclose(out_file);
}

#line 242 "PE_replay.sc"
void PE_node::compute_currents()
{   




    int i;
    for(i = 0; i < 1024; i++ )
    {   
	unsigned int t_arr; unsigned int t_diff;
	t_arr = time_arr[i];
	t_diff = time - t_arr;

	if (t_arr != 0 && t_diff >= 0 && t_diff <= 500) {
	    _specc::waitfor((500));
	}
	else 

	    if (t_arr != 0 && t_diff > 500)
		arr_spikes[i] = 0;
    }
}



void PE_node::compute_voltages()
{   
    int i;
    unsigned int n;
    printf("At time %f", time * 1.000000000000000e-01);


    for(i = 0; i < 1024; i++ )
    {   

	if (ref_period[i] != 0)
	{   
	    ref_period[i]-- ;
	}
	else 

	{   


	    _specc::waitfor((500));
	    if (t_spikes[spikes_i] == time)
	    {   
		n = spikes[spikes_i];
		if (ref_period[n] != 0) ref_period[n]-- ;
		else  {

		    ref_period[n] = 200;
		    send_spikes(n);
		    spikes_i++ ;
		    printf(" %d Spiked ", n);
		}
	    }
	}
    }


    printf("\n");
}

#line 169 "PE_replay.sc"
void PE_node::initialize()
{   
    int i; int j;
    my_PE_addr = id;

    for(i = 0; i < 1024; i++ )
	for(j = 0; j < 1024; j++ )
	    post_addresses[1024 * i + j] = 2863267840u;

    read_mapping();
}

#line 305 "PE_replay.sc"
void PE_node::main()
{   

    initialize();


    while(time < 500)
    {   

	read_spikes_external();
	compute_currents();
	compute_voltages();

	time = time + 1;
    }

    accumulate_stats();
    print_spikes();
}

#line 36 "PE_replay.sc"
void PE_node::print_spikes()
{   
    int i;
    for(i = 0; i < 1024; i++ )
    {   
	printf("Spikes for neuron %d: %d\n", i, spikes[i]);
    }
}

void PE_node::print_times()
{   
    int i;
    for(i = 0; i < 1024; i++ )
    {   
	printf("Spike for neuron %d at %fms\n", i, time * 1.000000000000000e-01);
    }
}

void PE_node::read_mapping()
{   
    struct _IO_FILE *input_file;
    char val_string[8000];
    char ch;
    int first = 0; int valid = 0;
    float value_f;
    unsigned int value_i;
    int i = 0; int neuron = 1; int synapse = 0;
    input_file = fopen("connectivity_matrix_mod", "r");

    while(( -1) != (ch = fgetc(input_file)))
    {   
	if (ch == '\n')
	{   
	    i = 0;
	    synapse = 0;
	    first = 0;
	    valid = 0;
	}
	else  if (ch == ' ')
	    {   
		unsigned int adr = 0u;
		val_string[i] = '\000';
		value_i = atol(val_string);
		adr = value_i & 4294901760u;

		if (first != 0 && valid == 1)
		{   
		    post_addresses[1024 * neuron + synapse] = value_i;
		    synapse++ ;
		}
		else 
		{   
		    if (adr == PE_ADDR[my_PE_addr])
		    {   
			neuron = value_i & 65535;
			first++ ;
			valid = 1;
		    }
		}

		i = 0;
	    }
	    else 
	    {   
		val_string[i] = ch;
		i++ ;
	    }
    }

    fclose(input_file);

    neuron = 0;
    input_file = fopen("spike_matrix_mod", "r");
    i = 0;
    while(( -1) != (ch = fgetc(input_file)))
    {   
	if (ch == '\n')
	{   
	    unsigned int adr = 0u;
	    val_string[i] = '\000';
	    value_i = atol(val_string);
	    adr = value_i & 4294901760u;
	    if (adr == PE_ADDR[my_PE_addr])
	    {   
		spikes[max_spikes] = value_i & 65535;
		max_spikes++ ;
	    }
	    i = 0;
	}
	else 
	    if (ch == ' ')
	    {   
		val_string[i] = '\000';
		value_f = atof(val_string);
		t_spikes[max_spikes] = value_f * 10;
		i = 0;
	    }
	    else 
	    {   
		val_string[i] = ch;
		i++ ;
	    }
    }
    fclose(input_file);
}

#line 202 "PE_replay.sc"
void PE_node::read_spikes_external()
{   
    packet p;
    int i;

    register_spikes(p.sender, p.target, p.time);


    for(i = 0; i < 37; i++ )
	if (PE_ADDR[i] == (p.sender & 4294901760u)) {
	    comm[i]++ ;
	    break;
	}
}

#line 181 "PE_replay.sc"
void PE_node::register_spikes(unsigned int input_neuron_addr, unsigned int dest_neuron_addr, unsigned int t_local)
{   


    unsigned int t_delay = 0u;


    int i;
    i = dest_neuron_addr & 65535;

    if (time > (t_local + t_delay)) printf("Sync error\n");



    arr_spikes[i]++ ;
    time_arr[i] = ((time_arr[i] * (arr_spikes[i] - 1)) + t_local) / arr_spikes[i];


    _specc::waitfor((500));
}

#line 224 "PE_replay.sc"
void PE_node::send_spikes(unsigned int neuron_num)
{   
    int j;
    unsigned int neuron_addr; unsigned int post_PE_addr; unsigned int post_addr;
    neuron_addr = PE_ADDR[my_PE_addr] + neuron_num;
    for(j = 0; j < 1024; j++ )
    {   
	post_addr = post_addresses[1024 * neuron_num + j];
	if (post_addr != 2863267840u)
	{   
	    post_PE_addr = post_addr & 4294901760u;
	    if (post_PE_addr == PE_ADDR[my_PE_addr]) send_spikes_internal(neuron_addr, post_addr, time);
	    else  send_spikes_external(neuron_addr, post_addr, time);
	}
    }
}

#line 217 "PE_replay.sc"
void PE_node::send_spikes_external(unsigned int neuron_addr, unsigned int post_addr, unsigned int t_local) {
}
void PE_node::send_spikes_internal(unsigned int neuron_addr, unsigned int post_addr, unsigned int t_local)
{   
    register_spikes(neuron_addr, post_addr, t_local);
}

#line 454 "main.cc"
Main::Main(unsigned int _idcnt)
    : _specc::class_type(_idcnt),
    i(0u),
    PE_0(_IDcnt, i)
{   
}

Main::~Main(void)
{   
}

#line 12 "main.sc"
int Main::main()
{   
    PE_0.main();
    return 0;
}

#line 473 "main.cc"
Main _scc_main(_IDcnt);

int main()
{   
    int _scc_main_return;
    
    _specc::start();
    _scc_main_return = _scc_main.main();
    _specc::end();
    return(_scc_main_return);
}

// function definitions //////////////////////////////////////////////

#line 13 "neuron_model.sh"
float LIF_slope(float V, float I)
{   
    float ret_val; float t1; float t2;
    t1 = V -  -70;
    t2 = I - 30 * t1;
    ret_val = t2 / 300;
    return ret_val;
}

#line 9 "synapse_model.sh"
float synaptic_current(unsigned int w, float t_diff)
{   
    float I;
    I = 1 * w * (exp(( -t_diff) / 15) - exp((( -t_diff) * 4.000000000000000e+00) / 15));
    return I;
}

#line 506 "main.cc"
void _scc_bit4_err_handle(
    const _bit4& bit4vec)
{   
    char temp_bits[1024], *p;
    p=bit2str(2,&temp_bits[1023], bit4vec);
    _specc::abort(
	"ERROR:\t Casting a bit4 vector failed \n"
	"Bit4 vector contains X/Z values %s\n"
	"Simulation aborted.\n", p);
	
}

//////////////////////////////////////////////////////////////////////
// End of file main.cc
//////////////////////////////////////////////////////////////////////
